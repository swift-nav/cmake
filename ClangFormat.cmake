#
# A module to create custom targets to format source and header files in a git repo
#
# The function swift_setup_clang_format will create several targets which will
# use clang-format to format source code according to a configuration file. 2 types
# of targets will be created, one for formatting all files in the repository and the
# other for formatting only the files which differ from master. The list of files to
# format is generated by git itself. 
#
# The created targets have the names
#
# - clang-format-all-${PROJECT_NAME} - formats all files in the repo
# - clang-format-diff-${PROJECT_NAME} - formats only changed files
#
# In addition if the current project is at the top level of the working tree 2 more
# targets will be created
#
# - clang-format-all
# - clang-format-diff
#
# which are aliases for the namespaced targets. If every project in a working
# directory uses this module to create auto-formatting targets there will never be
# a name clash
#
# The parameter SCRIPT can be used to specify a custom formatting command instead
# of calling clang-format directly. This should be executable and will be called
# with a single argument of either 'all' or 'diff' according to the target
#
# clang-format-all-${PROJECT_NAME} will run `<script> all`
# clang-format-diff-${PROJECT_NAME} will run `<script> diff`
#
# If a script is not specified explicitly this function will first search for an
# appropriate script. It must live in ${CMAKE_CURRENT_SOURCE_DIR}/scripts and be
# named either clang-format.sh or clang-format.bash. If found the custom targets
# will run this script with the same parameters as above
#
# If not script is found or specified default formatting commands will be run.
# This function will find an appropriate clang-format program and run it against
# the file list provided by git.
#
# The list of program names can be overriden by passing the CLANG_FORMAT_NAMES
# parameter with a list of names to search for
#
# All commands will be run from the source directory which calls this function.
# It is highly recommended to include this module and call swift_setup_clang_format
# from the top level CMakeLists.txt, using in a subdirectory may not work as
# intended.
#
# In addition this function sets up a cmake option which can be used to control
# whether the targets are created either on the command line or by a super project.
# The option has the name
#
# ${PROJECT_NAME}_ENABLE_CLANG_FORMAT
#
# The default value is ON for top level projects, and OFF for any others.
#
# Running 
#
# cmake -D<project>_ENABLE_CLANG_FORMAT=OFF ..
#
# will explicitly disable these targets from the command line at configure time
#

# Helper function to actually create the targets, not to be used outside this file
function(create_targets)
  set(argOption "")
  set(argSingle "TOP_LEVEL")
  set(argMulti "ALL_COMMAND" "DIFF_COMMAND")

  cmake_parse_arguments(x "${argOption}" "${argSingle}" "${argMulti}" ${ARGN})

  add_custom_target(clang-format-all-${PROJECT_NAME}
      COMMAND ${x_ALL_COMMAND}
      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
      )
  add_custom_target(clang-format-diff-${PROJECT_NAME}
      COMMAND ${x_DIFF_COMMAND}
      WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
      )

  # Top level projects will create the targets clang-format-all and
  # clang-format-diff with the same commands as the namespaced targets
  # above. However, cmake doesn't support aliases for non-library targets
  # so we have to create them fully.
  if(x_TOP_LEVEL)
    add_custom_target(clang-format-all
        COMMAND ${x_ALL_COMMAND}
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        )
    add_custom_target(clang-format-diff
        COMMAND ${x_DIFF_COMMAND}
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
        )
  endif()
endfunction()

# External function to create clang-format-* targets. Call according to the
# documentation in the file header.
function(swift_setup_clang_format)
  set(argOption "")
  set(argSingle "SCRIPT")
  set(argMulti "CLANG_FORMAT_NAMES")

  cmake_parse_arguments(x "${argOptions}" "${argSingle}" "${argMulti}" ${ARGN})

  # Keep track of whether the project cmake option should be on or off by default
  set(default_option_state ON)

  # Global clang-format enable option, influences the default project specific enable option
  option(SWIFT_ENABLE_CLANG_FORMAT "Enable auto-formatting of code using clang-format globally" ON)
  if(NOT SWIFT_ENABLE_CLANG_FORMAT)
    set(default_option_state OFF)
  endif()

  if(${PROJECT_NAME} STREQUAL ${CMAKE_PROJECT_NAME})
    # This is the top level project, ie the CMakeLists.txt which cmake was run
    # on directly, not a submodule/subproject. We can do some special things now.
    # The option to enable clang formatting will be enabled by default only for
    # top level projects. Also the top level project will create an alias target
    # clang-format-all against the project specific target
    set(top_level_project ON)
  else()
    set(top_level_project OFF)
    # Projects which are not top level have formatting disabled by default
    set(default_option_state OFF)
  endif()

  # We are going to generate two commands, all and diff, which could be a script or a call
  # directly o clang-format. These commands may or may not be found so keep track of whether
  # they are valid. Once they are valid we will be able to create the cmake option and
  # the actual targets
  set(commands_valid FALSE)
  unset(status_message)
  unset(failure_message)

  # If a custom script has been specified always use that by default
  if(x_SCRIPT)
    if(EXISTS ${x_SCRIPT})
      set(status_message "Initialising clang format targets for ${PROJECT_NAME} using existing script in ${x_SCRIPT}")
      set(all_command ${x_SCRIPT} all)
      set(diff_command ${x_SCRIPT} Diff)
      set(commands_valid TRUE)
    else()
      # The project has specified a script to use but it doesn't exist. Since this is a
      # option that comes directly from project code and not a user configuration option
      # we can bail out early
      message(FATAL_ERROR "Specified clang-format script ${x_SCRIPT} doesn't exist")
    endif()
  endif()

  if(NOT commands_valid)
    # Search for a custom formatting script in some reasonable places
    set(custom_scripts "${CMAKE_CURRENT_SOURCE_DIR}/scripts/clang-format.sh" "${CMAKE_CURRENT_SOURCE_DIR}/scripts/clang-format.bash")

    foreach(script ${custom_scripts})
      if(EXISTS ${script})
        # Found a custom formatting script. Set up the commands now but hold off creating
        # the targets for the moment until we know whether or not they are actually enabled
        set(status_message "Initialising clang format target for ${PROJECT_NAME} using existing script in ${script}")
        set(all_command ${script} all)
        set(diff_command ${script} diff)
        set(commands_valid TRUE)
      endif()
    endforeach()
  endif()

  if(NOT commands_valid)
    # Did not find any script to use, generate a default formatting command to process all code files in the repo

    # First try to find clang-format
    if(NOT x_CLANG_FORMAT_NAMES)
      set(x_CLANG_FORMAT_NAMES 
#clang-format60 clang-format-6.0
#clang-format40 clang-format-4.0
#clang-format39 clang-format-3.9
#clang-format38 clang-format-3.8
#clang-format37 clang-format-3.7
#clang-format36 clang-format-3.6
#clang-format35 clang-format-3.5
#clang-format34 clang-format-3.4
#clang-format
          asdfasdfasdfasdf
        )
    endif()
    find_program(CLANG_FORMAT NAMES ${x_CLANG_FORMAT_NAMES})
  
    if("${CLANG_FORMAT}" STREQUAL "CLANG_FORMAT-NOTFOUND")
      # Can't find a valid clang-format. We can still continue and just not create
      # the targets so set the default enable option state to off. Also set up
      # a failure message just in case the user is trying to force the targets
      # to be created even though we don't have a formatter
      set(failure_msg "Could not find appropriate clang-format, can't create targets")
      set(default_option_state OFF)
    else()
      set(success_msg "Using ${CLANG_FORMAT} to auto-format ${PROJECT_NAME} sources")
      set(${PROJECT_NAME}_CLANG_FORMAT ${CLANG_FORMAT} CACHE STRING "Absolute path to clang-format for ${PROJECT_NAME}")
        
      # Format all source and header files in the repo, use a git command to build the file list
      set(default_patterns "*.[ch]" "*.cpp" "*.cc" "*.hpp")

      set(all_command git ls-files ${default_patterns} | xargs ${${PROJECT_NAME}_CLANG_FORMAT} -i)
      set(diff_command git diff --diff-filter=ACMRTUXB --name-only master -- ${default_patterns} | xargs ${${PROJECT_NAME}_CLANG_FORMAT} -i)
      set(commands_valid TRUE)
    endif()
  
  endif()

  # Create a cmake option to enable formatting of this specific project
  option(${PROJECT_NAME}_ENABLE_CLANG_FORMAT "Enable auto-formatting of code using clang-format for project ${PROJECT_NAME}" ${default_option_state})

  if(${PROJECT_NAME}_ENABLE_CLANG_FORMAT)
    # Auto-formatting has been enabled, either by the default option or because a user
    # has explicitly enabled it on the command line
    if(commands_valid)
      # We have some valid commands to start the linting process so we 
      # can create the targets
      message(STATUS "${success_msg}")
      create_targets(
          TOP_LEVEL ${top_level_project}
          ALL_COMMAND ${all_command}
          DIFF_COMMAND ${diff_command}
          )
    else()
      # Without valid commands formatting is impossible. If we get here then the user
      # has explicitly tried to enable auto-formatting on the command line, since that
      # is impossible we will throw a fatal error here using a message previously
      # generated
      message(FATAL_ERROR "${failure_msg}")
    endif()
  else()
    # Formatting is etiher not possible or not requested for this project, skip
    # target creation
    if(failure_msg)
      # We may have encountered an error, but since the target would have been
      # disabled anyway it's not a big deal. Just log it so the user is aware
      message(STATUS "${failure_msg}")
    endif()
    message(STATUS "clang-format for project ${PROJECT_NAME} is DISABLED")
  endif()
endfunction()
